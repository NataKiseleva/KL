# -*- coding: utf-8 -*-
"""Practical 6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BwXD83tvw_PntavSXfVKQfy-Zvd2GeZd
"""

# Commented out IPython magic to ensure Python compatibility.
# %%bash
#  seq 1 5 | awk '{print $1 * 2}'

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# paste <(seq 1 5) <(seq 11 15) | awk '{$3 = $1 + $2; print}'

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# paste <(seq 1 5) <(seq 11 15) | awk '{print $1 + $2}'

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_sum.py
#

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_sum.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_sum.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_mean.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_mean.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_mean.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_median.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_median.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_median.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_variance.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_variance.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_variance.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_stddev.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_stddev.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_stddev.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x stats_mad.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g stats_mad.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# seq 1 5 | ./stats_mad.py

import subprocess

# open a subprocess with two-way communication
# if simply `"./stats-sum"` doesn't work, you can try
# passing the array `["python3", "./stats-sum"]`
my_subprocess = subprocess.Popen("./stats-sum.py",
    stdin=subprocess.PIPE, stdout=subprocess.PIPE)

for x in [1,2,3]:
  # need to encode the string, because we communicate binary
  # it needs a linebreak, because that is how we separate records
  my_subprocess.stdin.write("{}\n".format(x).encode('utf-8'))

# inform the subprocess that is the end of input
my_subprocess.stdin.close()

# read the binary result, and decode
# don't double the newlines
print(my_subprocess.stdout.read().decode('utf-8'), end='')

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# chmod +x gl.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# sed -i s/\r/\n/g gl.py

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# paste <(seq 1 10) <(seq 1 10) <(seq 1 10) | ./gl.py mean median variance

import subprocess
import sys
pr = []
# open a subprocess with two-way communication
# if simply `"./stats-sum"` doesn't work, you can try
# passing the array `["python3", "./stats-sum"]`
for st in sys.argv[:1]:
  pr.append(my_subprocess = subprocess.Popen("./stats_%s.py" % (st),
    stdin=subprocess.PIPE, stdout=subprocess.PIPE))

for l in sys.stdin:
  inputs = l.strip().split('\t')
  # need to encode the string, because we communicate binary
  # it needs a linebreak, because that is how we separate records
  for x, my_subprocess in zip(inputs, pr):
    my_subprocess.stdin.write("{}\n".format(x).encode('utf-8'))

# inform the subprocess that is the end of input
[my_subprocess.stdin.close() for my_subprocess in pr]

# read the binary result, and decode
# don't double the newlines
[print(my_subprocess.stdout.read().decode('utf-8'), end='') for my_subprocess in pr]